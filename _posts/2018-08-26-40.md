---
layout: post
title:  "임시포스팅1"
date:   2018-08-16 13:47:35 +0900
categories: TensorFlow
tag: tensorflow
---
### 1. Big-O

#### 시간 복잡도

시간 복잡도의 개념으로 사용된는 Big-O는 점근적 실행 시간을 뜻한다. 예를 들어서 비행기를 타고 데이터를 옮긴다고하면 $O(1)$이 되지만 일반적으로는 $O(n)$이 된다.

#### Big-$O$ vs Big-$\Theta$ vs Big-$\Omega$**

* Big-$O$
시간의 상한을 나타낸다. 예를 들어 배열 출력은 $O(N)$도 되지만 $O(N^2)$도 될 수 있다.

* Big-$\Omega$
시간의 하한을 나타낸다.

* Big-$\Theta$
$O$와 $\Theta$ 모두를 포함하는 개념이다. 정확한 시간을 뜻한다.


#### 시간 복잡도 계산 예제

**예제1**
```Java
void foo(int[] array){
  int sum=0;
  int preoduct =1;
  for (int i=0; i<array.length; i++){
    sum+=array[i];
  }
  for (int i=0; i<array.length; i++){
    preduct*=array[i]
  }
  System.out.preintln(sum + ", "+ product);
}
```

시간 복잡도는 $O(N)$이 된다. 배열은 두번 부르든 한번 부르든 모두 같다. 엄밀히 따지면 $O(N)$, $O(2N)$이지만 big-O의 시간 복잡도 개념으로는 같다.

> Big-O는 상수항을 무시한다. 즉 $O(2N)$을 $O(N)$으로 표기하는 것이다. 이유는 우선 Big-O의 경우 증가하는 비율을 나타내는 개념이기 때문이다. 그리고 $O(N)$이 $O(2N)$ 보다 항상 빠른것도 아니다.

**예제2**

```Java
void preintPairs(int[] array){
  for(int i = 0; i<array.lenght; i++){
    for(int j =0; j<array.length; j++){
      System.out.println(array[i]+", "array[j]);
    }
  }
}
```

이 예제의 경우에는 N번 루프안에 루프가 N번 반복하므로 $O(N^2)$이 된다.

**예제3**

```java
void printunorderedPairs(int[] array) {
 for (int i = 6; i < array.length; i++) {
   for (int j = i + 1; j < array.length ; j++) {
      System.out . println (array[i] + "," + array[j]);
    }
  }
}
```

위의 예제와 매우 비슷하지만 안쪽의 Loop가 i+1부터 시작되는 점이 다르다 따라서 결과는 다음과 같은 방법으로 계산된다.

$$
(N-1)+(N-2)+...+2+1 = \frac{N(N-1)}{2}
$$

따라서 $O(N^2)$이된다. 결국 예제2와 같다.

**예제4**

```java
void pri ntUnorderedPairs(int[] arrayA, int[] arrayB) {
 for (int i = 0; i < arrayA.length; i++) {
   for (int j = 0; j < arrayB.length; j++) {
     if (arrayA[i] < arrayB[j]) {
       System.out.println(arrayA[i] + "," + arrayB[j]);
      }
    }
  }
}
```

이 예제의 시간 복잡도는 $O(AB)$가 된다. $O(N^2)$가 아닌것에 유의하자.

**예제5**

이 예제는 살짝 애매하다 코드를 보자.
```Java
void printUnorderedPairs(int[] arrayA, int[] arrayB) {
 for (int i = e; i < arrayA.length; i++) {
   for (int j = e; j < arrayB.length; j++) {
     for (int k = e; k < 100000; k++) {
       System.out.println(arrayA[i] + "," + arrayB[j]);
      }
    }
  }
}
```

중간에 100000번 반복문이 있어 $O(100000AB)$로 생각할 수 있지만 Big-O는 상수항을 무시한다는 것을 명심하자. 결국 $O(AB)$가 된다.

**예제6**

```java
void reverse(int[] array) {
 for (int i = e; i < array.length / 2; i++) {
   int other = array.length - i - 1;
   int temp = array[i];
   array[i] = array[other];
   array[other] = temp;
 }
}
```

배열 절반을 보지만 결국 $O(N)$이 된다.

**예제7**

다음 중 $O(N)$과 같은 것은?

* $O(N+P), P<\frac{N}{2}$
* $O(2N)$
* $O(N+logN)$
* $O(N+M)$

결과는 1,2,3번이다.

**예제8**

여러개 문자열 구성된 배열 주어졌을 때 각 문자열 먼저 정렬하고 다음에 전체 문자열을 사전순으로 정렬하는 문제의 Big-O는?

여기서 $O(N^2logN)$이라고 대답하면 틀린다. 우선 문자열길이와 배열 크기를 똑같은 N으로 사용한 것이 가장 큰 문제점이다 따라서 다음과 같이 정의한 후 시작한다.

* 가장 긴 문자열 s
* 배열 길이 a

시간 복잡도는 다음과 같이 계산된다.

* 각 문자열 정렬하는데 $O(s\log s)$소요
* 총 a개 이므로 $O(as\log s)$ 소요
* 전체 문자열 사전순 정렬 시 틀린 대답 : $O(a\log a)$
* 전체 문자열 사전순 정렬 시 올바른 대답 : 우선 문자열 두개 비교하는 시간은 $O(s)$ (character 하나씩 전체 비교해야함), 그리고 총 $O(a\log a)$번 비교해야 하므로 결론적으로 $O(as\log a)$소요

전체 소요시간은 $O(as(\log a +\log s))$이다.

**예제 9**

```java
int sum(Node node) {
 if (node == nUll) {
   return a;
 }
 return sum(node . left) + node. value + sum(node.right);
}
```

이진 탐색 트리의 전체 합을 구하는 문제이다. 구하는 방법을 생각해보자. 의미적으로 해석을 하면 전체 노드를 돌아야 하므로 $O(N)$이다.

또 다른 방법으로 해석해보자. 재귀호출 패턴 분석을 해보면 이진 트리 구조이므로 일반적으로 $O(2^\text{depth})$가 될 것이다. 여기서 전체 node가 $N$개 이므로 depth는 이진 트리라는 것을 고려하면 $\log N$이 된다. 따라서 수행시간은 $O(2^{\log N})$이 되므로 결국 $O(N)$이 된다.

**예제 10**

소수를 구하는 문제를 생각하자.

```java
boolean isPrime(int n) {
  for (int x = 2; x * x <= n; x++) {
    if (n % x == 0) {
      return false;
    }
  }
  return true;
}
```


최악의 경우를 생각해보면 된다. 반복문은 $\sqrt{n}$번 반복하므로 시간 복잡도는 $O(\sqrt{N})$이 된다.

**예제 11**

factorial 구하는 코드이다.

```java
int factorial(int n) {
  if(n < e){
    return -1;
  } else if (n == e) {
    return 1;
  } else {
    return n * factorial(n - l);
  }
}
```

단순히 1부터 N까지 반복하므로 $O(N)$이 된다.

**예제 12**

순열(permutation)의 개수를 코드이다.

```java
void permutation(String str) {
  permutation(str, "");
  }

void permutation(String str, String prefix) {
  if (str.length() == 0) {
    System.out.println(prefix)j
  } else {
    for(int i = 0; i < str.length(); i++) {
      String rem = str.substring(0, i) + str.substring ( i + 1);
      permutation(rem, prefix + str.charAt(i));
    }
  }
}
```

여러 방면으로 Big-O에 대해서 생각해보자.

우선은 permutation 함수의 호출 횟수를 생각해보면 $n!$이 될 것이다.

다음으로는 for문안에서 몇 개의 노드가 생성될지를 생각해보자. 호출 트리를 생각해보면된다. 말단 노드는 $n!$이 될 것이다. 그리고 각 루트에 대해서 말단까지는 거리가 $n$이 최대일 것이다. 따라서 전체 노드 개수는 $n\cdot n!$을 넘지 못한다.

마지막으로 string을 print하는 함수는 $O(n)$ 시간이 걸린다.

따라서 결과적으로 전체 시간은 $O(n^2* n!)$을 넘지 못할 것이다.

**예제 14**

피보나치 수열을 구하는 문제이다.

```Java

int fib(int n) {
  if (n <= 0) return 0;
  else if (n == 1) return 1;
  return fib(n - 1) + fib(n - 2);
}
```

재귀적로 호출된다. 따라서 $O(2^N)$이 될 것이다.

**예제 15**

```java
void allFib(int n) {
  for (int i = 8; i < n; i++) {
    System.out.println(i + ":" + fib(i));
  }
}

int fib(int n) {
  if (n <= 0) return e0;
  else if (n == 1) return 1;
  return fib(n - 1) + fib(n - 2);
}
```

0부터 n까지 피보나치 수열 전부를 출력하는 코드이다. 시간복잡도를 살펴보자.

잘못된 대답은 fib함수가 $O(2^n)$이고 총 $n$번 출력되므로 $O(n2^n)$으로 성급하게 대답할 수 있다.

하지만 호출 되는 횟수를 생각해보자.

$\text{fib}(1) - 2^1$번 호출
$\text{fib}(2) - 2^2$번 호출
$\text{fib}(3) - 2^3$번 호출
...
$\text{fib}(n) - 2^n$번 호출

즉 다음의 횟수로 호출될 것이다.

$2^1 + 2^2 + ... + 2^n$

따라서 $2^{n+1}$이 된다. 즉 $O(2^n)$이 된다.

**예제 15**

이번에도 피보나치 수열을 전부 출력하는 코드이다. 하지만 이번에는 계산된 결과값을 정수 배열에 저장하는(즉 캐시하는) 문제이다.

```Java
void allFib(int n) {
  int[] memo = new int[n + 1];
  for (int i = 0; i < n; i++) {
    System.out.println(i + ": " + fib(i, memo));
  }
}

int fib(int n, int[] memo) {
  if (n <= 0) return 0;
  else if (n == 1) return 1;
  else if (memo[n] > e) return memo[n];
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
}
```

이 떄의 시간 복잡도는 $O(N)$이 된다.

**예제 16**

1과 n을 포함해 사이의 모든 2의 승수를 출력하는 함수이다.

```Java
int powersOf2(int n) {
  if (n < 1) {
    return 0;
  } else if (n == 1) {
    System.out.println(l);
    return 1;
  } else {
    int prev = powersOf2(n / 2);
    int curr = prev * 2;
    System.out.println(curr);
    return curr;
  }
}
```

시간 복잡도를 생각해보자.

무었을 의미하는 지 생각해보면 쉽게 계산할 수 있다. 2의 승수를 출력하는 것이므로 그 개수만큼 호출될 것이다. 즉 1과 n사이에는 $\log n$개의 승수가 있으므로 $O(\log n)$이 된다.

수행시간 증가 속도 측면에서 생각 해보자. n이 커질 때 생각하면 된다. N이 P에서 P+1이 됬을 때 생각해보면 호출횟수는 안바뀔 가능성이 크다.
그렇다면 호출횟수가 변할 때는 언제인가? 2배가 되었을 때이다. 즉 $2^x=n$인 $x$를 찾으면 된다. 따라서 $O(\log n)$이 된다.

#### 추가문제
1. O(b)
2. O(1) *틀림* O(logb)
3. O(1)
4. O(a/b)
5. O(logN)
6. O($\sqrt{N}$)
7. O(N)
8. O(logN) *틀림* O(N)
9. O($N^2$)
10. O(log N)
11. *어려움 다시확인!!*
12. O(AlogB)

---

### 2. 기술적 문제

#### 기술적인 문제 준비하기

아래와 같은 기준으로 기술적 문제 연습해라.

* **직접 풀도록 노력해라**
힌트는 봐도 괜찮다 실제로 면접과정에서 문제를 해결하는 과정을 보기 위해 중간중간 힌트를 주기도 한다. 하지만 답을 보는 것은 의미가 없다. 뿐만 아니라 문제를 풀 때 시간과 공간 복잡도도 항상 생각하라.

* **코드를 종이에 적으라**
에디터로 코딩을 하면 여러 자동완성등 기능이 제공되지만 실제 면접에서는 그런 기능들을 제공받기 힘들다. 따라서 종이에 코드를 작성하는 상황에 익숙해지자.

* **코드를 테스트해라**
코드를 테스트해봐라 물론 종이에서 해야 한다. 기본 조건, 오류 조건등 가능한 상황 모두를 테스트해라.

* **종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라**
실수들을 기록하고 정리해야 한다.

#### 알고 있어야 할 것들

**핵심 자료구조, 알고리즘, 기본 개념**

아래의 표에 나오는 것들은 기본적으로 모두 알고 있어야 한다. 면접과정에서 생각보다 그렇게 어려운 것들은 나오지 않는다. 결국 기본이 제일 중요하다.

자료구조|알고리즘|개념
-----|--------|---
연결리스트(Linked List)|너비 우선 탐색(Breadth-First Search)|비트 조작(Bit Manipulation)
트리, 트라이(Tries), 그래프|깊이 우선 탐색(Depth-First Search)|메모리(스택 vs 힙)
힙(Heaps)|병합 정렬(Merge Sort)|동적 프로그래밍(Dynamic Promgramming)
Vector/ArrayList|퀵 정렬| big-O 시간&공간
해시테이블||


위의 모든 내용들이 매우 중요하다. 이미 알고 있다 하더라도 밑바닥부터 구현하는 연습을 해보자.
특히 해시 테이블은 매우 중요한 주제다. 능숙하게 다룰 수 있도록 연습하자.

**2의 승수(power of 2) 표**

아래의 2의 승수는 메모리 제한 및 규모 확장성 관련 문제를 풀 때 유용하다. 반드시 외울 필요는 없지만 외우면 유용하다.

X|$2^X$|근사치|메모리 요구량
-|-|-|-
7|128||
8|256||
10|1024|1,000(천)|1K
16|65,536||64K
20|1,048,576|1,000,000(백만)|1MB
30|1,073,741,823|1,000,000,000(십억)|1GB
32|4,294,967,296||4GB
40|1,099,511,627,776|1,000,000,000,000(조)|1TB

#### 실제 문제 살펴보기

**면접문제를 풀어가는 과정**

다음과 같은 순서로 문제를 해결해 나가자.

1. **문제를 경청해서 듣기**

우선 문제의 모든 정보를 잘 들어야 한다. 말할 때 모든 정보를 최대한 다 체크하도록 하자.

2. **예제를 직접 그려보기**

문제를 듣고 바로 풀어보려는 경우가 많은데 그 전에 먼저 예제를 직접 그려보면 차원이 다른 문제풀이 능력을 발휘할 수 있을 것이다. 예제를 만들 때는 다음을 유의해서 생각하자.

* 명확한 예제를 쓰자: 문제에 맞는 실제 숫자와 문자열 사용하자.
* 충분히 큰 예제를 쓰라: 충분히 큰 예제를 작성하자.
* 특별한 예제를 지양하자: 무심코 특별한 예제를 그리는 경우를 주의하자.

3. **무식한 방법으로 일단 해보기**

우선은 Brute force방법으로 먼저 시도해보자. 이 단계에서는 최적화를 기대안해도 된다. 우선 만든 후 개선해 나가면 된다.

4. **최적화**

Brute force로 알고리즘을 만들었다면 최적화 과정을 가져야 한다. 최적화 과정에서 잘 먹히는 기술들은 다음과 같다.

* 간과한 정보가 있는지 찾아보자. 예를들면 배열이 정렬되어 있는지?
* 새로운 예제를 만들어 보자. 그러면 새로운 패턴을 발견할 수 있다.
* 잘못된 방식으로 문제를 풀어보자. 틀린 해법을 통해 올바른 해법을 찾을 수도 있다.
* 시간과 공간의 실익을 따져보고 균형을 맞추자.
* 정보를 미리 계산해 두자. 미리 계산한 정보를 저장하면 속도를 빠르게 할 수 있다.
* 해시 테이블을 사용하라. 해시 테이블은 면접문제에 널리 사용되는 개념이다.
* 가능한 최선의 수행 시간(BCR)을 생각하자.

5. **검토하기**

최적 알고리즘을 찾더라도 바로 코딩하지말고 잠시 생각하며 알고리즘에
대한 이해를 확실히 하자.

6. **코드 작성하기**

코드는 최대한 예쁘게 작성해야 한다. 화이트 보드에 코딩할 때 정렬 또한 매우 중요한 주제이다. 코드 작성 시 유의해야 하는 사항은 다음과 같다.

* 모듈화된 코드를 사용하라
* 에러를 검증하라
* 필요한 경우 다른 클래스나 구조체를 사용해라
* 좋은 변수명을 사용해라

7. **테스트**

면접장에서도 테스트없이 코드를 제출하면 안된다. 테스트 시 유의해야 할 상황은 다음과 같다.

* '개념적'테스트부터 시작하라. 즉 머리속에서 돌려보라.
* 코드에서 상황에 따라 달라지는 부분을 유심히 보라.
* 버그가 자주 발생하는 부분을 유심히 보라.
* 작은 규모의 테스트를 돌려보라.
* 특별한 경우, 즉 Null, 단일원소 등을 테스트해라.

#### 최적화 및 문제풀이 기술 (1): BUD를 찾으라

최적화 문제를 위한 가장 유용한 방법이다. BUD란 다음의 약자를 나타낸다.

* 병목현상(**B** ottleneck)
* 불필요한 작업(**U** nnecessary)
* 중복되는 작업(**D** uplicated Work)

알고리즘이 비효율적으로 동작하는 가장 흔한 이유가 이 세가지 이다. 이 세가지를 중점적으로 보면서 개선해 나가면 된다.

#### 최적화 및 문제풀이 기술 (2): 직접 풀어보라

알고리즘을 찾지 말고 직접 해결하보는 것이 알고리즘을 찾는데 도움이 될 것이다.

#### 최적화 및 문제풀이 기술 (3): 단순화 일반화 하라

여러 단순화, 일반화 접근법은 다음과 같다. 먼저 자료형과 같은 제약조건을 단순화 한다. 그 다음 단순화된 버전의 문제를 해결한다. 마지막으로 단순화된 문제의 알고리즘이 완성되면 해당 알고리즘 보다 복잡한 형태로 다듬어 간다.

#### 최적화 및 문제풀이 기술 (4): 초기 사례(base case)로 부터 확장하기

예를 들면 n=1 과 같은 초기 사례를 해결해보고 그 다음 n=2, n=3, n=4 등 점점 더 복잡한 케이스를 생각해보자.

#### 최적화 및 문제풀이 기술 (5): 자료구조 브레인 스토밍

이 방법은 은근히 너저분하지만 자주 통한다. 모든 자료구조를 하나씩 살펴보면서 적용해본다. 자료구조만 잘 찾더라도 문제가 자연스럽게 풀리는 경우가 있으므로 사용해보자.

---

### 3. 면접 문제

1~4 자료구조

1. 배열과 문자열(9문제)
2. 연결리스트(8문제)
3. 스택과 큐(6문제)
4. 트리와 그래프(12문제)

5~11 개념과 알고리즘

5. 비트 조작(8문제)
6. 수학 및 논리 퍼즐(10문제)
7. 객체 지향 설계(12문제)
8. 재귀와 동적 프로그래밍(14문제)
9. 시스템 설계 및 규모 확장성(8문제)
10. 정렬과 탐색(11문제)
11. 테스팅(6문제)

---

#### 배열과 문자열

**해시테이블**

해시테이블은 효율적인 탐색을 위한 자료구조로 key를 value에 대응한다. 해시 테이블을 구현하는 방법은 여러 가지가 있다. 여기에서는 간단하면서 흔하게 사용되는 구현 방식에 대해 설명한다.

간단한 해시테이블을 구현하기 위해서 Linked list와 Hash code function만 있으면 된다. key와 value를 Hash Table에 넣을 때는 다음의 과정을 거친다.

* 처음에 key의 Hash code를 게산한다. key는 보통 int 혹은 long이다. 키의 개수는 무한한데 반해 int는 유한하기 때문에 두 개의 key가 같은 hash code가리킬 수 있다.
* `hash(key) % array_length` 와 같은 방식으로 Hash code 이용해 배열의 index 구한다. 물론 서로 다른 두 개의 hash code가 같은 index 가리킬 수 있다.
* 배열의 각 index에는 key와 value로 이루어진 linked list가 있다. key와 value를 해당 index에 저장한다. 충돌 대비해 반드시 linked list이용해야 한다. 여기서 충돌은 두 개의 key가 같은 hash code가리키거나 서로 다른 두 개의 hash code가 같은 index가리키는 경우.

탐색과정에서는 주어진 key로 부터 hash code를 계산하고, 이 code를 이용해 index를 한다. 그리고 해당 key에 상응하는 linked list에서 탐색한다.

충돌이 자주 발생하면 시간 복잡도는 O(N)이지만 보통 해시 테이블에서 탐색 시간은 O(1)이다.

![1](https://i.imgur.com/ascLTIa.jpg)

또 다른 구현 방법으로는 balanced binary serach tree를 사용하는 방법이다. 이 때는 탐색은 O(log N)이 된다. 이 방법은 크기가 큰 배열을 미리 할당해 놓지 않아도 되기 때문에 적은 공간 사용한다는 장점이 있다.

**ArrayList와 가변 크기 배열**

특정 언어에서는 배열(보통 리스트라 불림)의 크기를 자동으로 조절할 수 있다. 하지만 자바 같은 언어는 고정되어 있다 따라서 동적 가변 크기 기능이 내재되어 있는 배열과 비슷한 자료구조 원할 떄는 ArrayList를 사용한다. 그리고 이 ArrayList는 O(1)의 접근시간을 유지한다. 엄밀히는 배열을 두 배 늘릴 때 O(N)이지만 보통 가득 안차있으므로 O(1)이다.

ArrayList에서 N개의 원소 넣으려면 중간중간 크기를 2배씩 계속 늘려야 한다. 하지만 이 시간을 모두 계산하더라도 N보다 작다 아래를 보자.

1개 되면 2개로 늘림: 1개 복사
2개 되면 4개로 늘림: 2개 복사
4개 되면 8개로 늘림: 4개 복사
...
n/4개 되면 n/2개로 늘림: n/4개 복사
n/2개 되면 n개로 늘림: n/2개 복사

총 복사해야 되는 수는 $1+2+4+...+\frac{n}{4} +\frac{n}{2}$
즉 n개 보다 작다.

문자열, 배열, 일반적인 자료구조 연습해 보는 가장 좋은 방법은 여러분만의 StringBuilder, HashTable, ArrayList를 구현해보는 것이다.

#### 면접 문제

**1.1 중복이 없는가**
문자열이 주어졌을 때, 이 문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘을 작성하라. 자료구조를 추가로 사용하지 않고 풀 수 있는 알고리즘 또한 고민하라.
> Is Unique: Implement an algorithm to determine if a string has all unique characters. What if you
cannot use additional data structures?

```java
boolean isUniqueChars(String str) {
  if (str.length() > 128) return false;
  boolean[] char_set = new boolean[128];
  for (int i = 0; i < str.length(); i++) {
    int val = str.charAt(i);
    if (char_set[val]) { // Already found this char in string
    return false;
  }
  char_set[val] = true;
  }
return true;
}
```

**1.2 순열 확인**
문자열 두 개가 주어졌을 때 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라.
> Check Permutation: Given two strings, write a method to decide if one is a permutation of the other.

```Java
String sort(String s) {
  char[] content = s.toCharArray();
  java.util.Arrays.sort(content);
  return new String(content);
  }

boolean permutation(String s, String t) {
  if (s.length() != t.length()) {
    return false;
  }
  return sort(s).equals(sort(t)) ;
}
```

```java
boolean permutation(String s, String t) {
  if (s.length() != t.length()) {
    return false ;
  }

  int[] letters = new int[128]; // Assumption

  char[] s_array = s.toCharArray();
  for (char c : s_array) { // count number of each char in s.
    letters[c]++;
  }

  for (int i = 0; i < t.length(); i++) {
    int c = (int) t.charAt(i);
    letters[c]--;
    if (letters[c] < 0) {
      return false;
    }
  }

  return true;
}
```

**1.3 URL화**
문자열에 들어 있는 모든 공백을 '%20'으로 바꿔 주는 메서드를 작성하라. 최종적으로 모든 문자를 다 담을 수 있을 만큼 충분한 공간이 이미 확보되어 있으며 문자열의 최종 길이가 함께 주어진다고 가정해도 된다.(자바로 구현한다면 배열 안에서 작업할 수 있도록 문자 배열(character array를 이용하길 바란다)

>URLify: Write a method to replace all spaces in a string with '%2e: You may assume that the string has sufficient space at the end to hold the additional characters, and that you are given the "true" length of the string. (Note: if implementing in Java, please use a character array so that you can perform this operation in place.)

**1.4 회문 순열**
주어진 문자열이 회문(palindrome)의 순열인지 아닌지 확인하는 함수를 작성하라. 회문이란 앞으로 읽으나 뒤로 읽으나 같은 단어 혹은 구절을 의미하며, 순열이란 문자열을 재배치하는 것을 뜻한다. 회문이 꼭 사전에 등장하는 단어로 제한될 필요는 없다.

> Palindrome Permutation: Given a string, write a function to check if it is a permutation of a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a re arrangement of letters. The palindrome does not need to be limited to just dictionary words.

일반적인 풀이법은 직접 푼 방법과 비슷 좀더 최적화를 위한 비트 벡터 사용한 풀이법은 다음과 같다.

```java
boolean isPermutationOfPalindrome(String phrase) {
  int bitVector = createBi tVector(phrase);
  return bitVector == 0 || checkExactlyOneBitSet(bitVector);
}

/* Create a bit vector for the string. For each letter with value i, toggle the i-th bit. */
int createBitVector(String phrase) {
  int bitVector = 6;
  for (char c : phrase.toCharArray()) {
    int x = getCharNumber(c);
    bitVector = toggle(bitVector, x);
  }
  return bitVector;
}

/* Toggle the ith bit in the integer. */
int toggle(int bitVector, int index) {
  if (index < 0) return bitVector;
  int mask = 1 << index;
  if ((bitVector & mask) == 0 ){
    bitVector |= mask;
  } else {
    bitVector &= ~mask;
  }
  return bitVector;
}

/* Check that exactly one bit is set by subtracting one from the integer and
 * ANDing it with the original integer. */
boolean checkExactlyOneBitSet(int bitVector) {
  return (bitVector & (bitVector - 1)) == 0;
}
```

**1.5 하나 빼기**
문자열을 편집하는 방법에는 세 가지 종류가 있다. 문자 삽입, 문자 삭제, 문자 교체. 문자열 두 개가 주어졌을 때, 문자열을 같게 만들기 위한 편집 횟수가 1회 이내인지 확인하는 함수를 작성하라.

> One Away: There are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit (or zero edits) away.


**1.6 문자열 압출**
반복되는 문자의 개수를 세는 방식의 기본적인 문자열 압축 메서드를 작성하라. 예를 들어 문자열 aabccccaaa를 압축하면 a2b1c5a3가 된다. 만약 '압축된' 문자열의 길이가 기존 문자열의 길이보다 길다면 기존 문자열을 반환해야 한다. 문자열은 대소문자 알파벳으로만 이루어져 있다.

>String Compression: Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2b1c5a3. If the "compressed" string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).


**1.8 0행렬**
M x N 행렬의 한 원소가 0인 경우, 해당 원소가 속한 행과 열의 모든 원소를 0으로 설정하는 알고리즘을 작성하라.

> Zero Matrix: Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to O.


---

#### 연결 리스트(Linked list)

연결리스트는 차례로 연결된 노드를 표현해주는 자료구조이다. 단방향과 양방향 연결리스트가 존재한다. 배열과는 달리 특정 인덱스를 상수 시간에 접근할 수 있다. 즉 리스트에서 K번쨰 원소 찾고 싶다면 처음부터 K번 루트를 돌아야 한다.

![2](https://i.imgur.com/CJw392a.jpg)

연결리스트의 장점은 리스트의 시작 지점에서 아이템을 추가하거나 삭제연산을 상수 시간에 할 수 있다는 점이다.

**연결 리스트 만들기**

책에는 java를 사용했지만 python으로 만들어 본다.

```python
class Node:

  def __init__(self, data, next = None):
  self.data = data

class LinkedList:

  def __init__(self, data):
    self.head = Node(data)


  def insert(self, data):
    current = self.head
    while current.next is not None:
      current = current.next
    current.next = Node(data)    
```

**단방향 연결리스트에서 노드 삭제**

노드 삭제는 LikedList 클래스 안에 다음과 같이 함수 하나만 추가해주면 된다.

```python

  def delete(self, data):
    current = self.head

    if current.data == data:
      self.head = self.head.next

    while current.next is not None:

      if current.next.data == data:
        current.next = current.next.next
        break

      current = current.next    
```

**Runner 기법**

Runner(부가 포인터라고도 한다)는 연결리스트 문제에서 많이 활용되는 기법으로, 연결리스트를 순회활 때 두 개의 포인터를 동시에 사용하는 것이다. 이 때 한 포인터가 다른 포인터보다 앞서도록 한다.

Runner 기법을 사용하는 예시를 보자. 예를 들어 다음과 같은 연결 리스트가 있다고 하자.

$$
a_1\rightarrow a_2\rightarrow...\rightarrow a_n\rightarrow b_1\rightarrow b_2\rightarrow...\rightarrow b_n
$$

이 때 이 연결리스트를 다음과 같이 정렬하려고 한다.

$$
a_1\rightarrow b_1 \rightarrow a_2\rightarrow b_2\rightarrow...\rightarrow a_n \rightarrow b_n
$$

그리고 우리는 이 연결리스트의 정확한 길이는 모르지만 짝수라는 사실은 안다. 이 경우에 우리는 두 개의 포인터 p1, p2를 만들고 p2가 한번 움직일 때 p1이 두번 움직이도록 한다. 그리고 p1이 리스트의 끝까지 가게 하면 p2는 리스트의 중간에 위치할 것이다. 그리고 다시 p1을 처음으로 오게한 뒤 p1, p2가 각각 가리키는 값들로 정렬해나가면 ㅇ아래와 같이 정렬할 수 있다.

**재귀 문제**

연결리스트 관련 문제는 상당수 재귀 호출과 관련되어 있다. 연결리스트문제를 푸는 데 어려움을 겪고 있다면, 재귀적 접근법은 통할지 확인해 봐야 한다.

#### 면접 문제**

**2.1 중복 없애기**
정렬되지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하라.
(연관 문제) - 임시 버퍼를 사용할 수 없다면 어떻게 풀 수 있을까?

> Remove Dups: Write code to remove duplicates from an unsorted linked list.

**2.2 뒤에서 k번째 원소 구하기**
단방향 연결 리스트가 주어졌을 때 뒤에서 k번째 원소를 찾는 알고리즘을 구현하라.

> Return Kth to Last: Implement an algorithm to find the kth to last element of a singly linked list.

**2.3 중간 노드 삭제**
단반향 연결리스트가 주어졌을 때 중간(정확히 가운데 노드일 필요는 없고 처음과 끝 노드만 아니면 된다)에 있는 노드 하나를 삭제하는 알고리즘을 구현하라. 단, 삭제할 노드에만 접근할 수 있다.

---

#### 트리와 그래프

면접에서 가장 까다로워 하는 문제 중 하나가 트리나 그래프 문제인 것 같다. 트리에서 search하는 것이 배열이나 연결리스트처럼 선형으로 구성된 자료구조에서 탐색하는 것보다 훨씬 까다롭다. 또한 최악의 수행 시간과 평균적 수행 시간이 매우 크게 바뀔 수 있어서, 알고리즘에 대해 두 가지 측면 모두를 반드시 따져야 한다.

#### 트리의 종류

* 트리는 하나의 루트 노드를 갖는다.(그래프 이론상 꼭 그래야 할 필요는 없지만 일반적인 프로그래밍, 그 중에서 프로그래밍 면접에서는 맞는 말이라 할 수 있다)
* 루트 노드는 0개 이상의 자식 노드를 갖고 있다.
* 그 자식 노드 또한 0개 이상의 자식 노들르 갖고 있고, 이는 반복적으로 정의된다.

트리는 cycle이 존재할 수 없다. Python으로 Tree를 구현해보자. 먼저 Node를 간단하게 정의하자.

```python
class Node:
  def __init__(self, value):
    self.value = value
    self.childNode = []
```

그리고 전체 Tree는 Root만 넣어주면 된다.

```python
class Tree:
  def __init__(self, value):
    self.root = Node(value)
```

트리 및 그래프에서는 대부분 세부사항이 매우 중요하다. 따라서 아래의 이슈들에 대해서 유의하고 명확히 해야 한다.

**Tree vs Binary Tree**

Binary tree는 각 노드가 최대 두 개의 자식을 갖는 트리를 말한다. 모든 트리는 binary tree 가 아니다. 일반적으로는 자식을 2개 이상 가질 수 있다.

**Binary Tree vs Binary Search Tree**

Binary Tree(이진 트리)와 Binary Search Tree(이진 탐색 트리)를 구분해야 한다. 구조는 갖지만 binary search tree의 경우 모든 노드들에 대해 left child 노드는 해당 노드보다 크기가 작아야 하고 right child 노드는 해당 노드보다 크기가 커야 한다.

![3](https://i.imgur.com/uHyuFDV.jpg)

이진 트리와 이진 탐색 트리를 각각 python으로 구현해 보자.

**Binary Tree**
이진 트리의 경우 기존의 트리와 구현이 크게 다른점이 없으므로 간단하게만 구현한다.

```python
class Node:
  def __init__(self, value):
    self.value = value
    self.leftChild = None
    self.rightChild = None

class Tree:
  def __init__(self, value):
    self.root = Node(value)

  def setRoot(..):
    ...

  def insert(..):
    ...

  def delete(..):
    ...

  ...
```

**Binary Search Tree**
이진 탐색 트리의 경우 구현이 쉽지는 않다. 특히 노드 삭제가 매우 어렵다. 삭제의 경우 삭제할 노드를 아래와 같이 구분해줘야 한다.

* 삭제할 노드의 자식 노드가 없는 경우

가장 간단한 구조이다. 그냥 삭제만 하면 끝난다.

![4](https://i.imgur.com/NigLpS6.jpg)

* 삭제할 노드의 자식 노드가 하나인 경우

이 경우도 그렇게 어렵지는 않다. 삭제한뒤 해당 노드의 부모에 해당 노드의 자식노드를 이어주면 끝난다.

![5](https://i.imgur.com/UqLOVak.jpg)

* 자식 노드가 2개인 경우

가장 문제가 되는 case다. 삭제후 바로 연결해 버리면 Binary Search Tree의 가정이 어긋나게 된다. 삭제하는 방법은 삭제한 노드의 우측 서브 트리에서 successor(최소값)을 찾는다. successor값을 삭제하는 노드의 값으로 지정해준다. 그리고 successor 노드를 지우면 된다. successor 노드의 경우 항상 자식노드가 하나 혹은 없을 수 밖에 없으므로 이 노드의 삭제는 간단하다.

![6](https://i.imgur.com/4xq6kFo.jpg)

Python으로 Binary Search Tree 구현한 것은 다음과 같다.

```python
class Node:
    def __init__(self, val):
        self.value = None
        self.leftChild = None
        self.rightChild = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def setRoot(self, value):
        self.root = Node(value)

    def search(self, value):

        if self.binarySearch(root, value): return self.binarySearch(root, value)

        else: return False

    def binarySearch(self, node, value):

        if node is None: return False

        else:
            if node.value > value:
                binarySearch(node.leftChild.value, value)

            elif node.value < value:
                binarySearch(no.rightChild.value, value)

            else return node

    def insert(self, value):
        if self.root is None:
            self.setRoot(value)
        else:
            self.insertNode(self.root, value)

    def insertNode(self, currentNode, value):

        if value >= currentNode:

            if currentNode.rightChild is None: currentNode.rightChild = Node(value)

            else self.insertNode(currentNode.rightChild, value)

        else:

            if currentNode.leftChild is None: currentNode.leftChild = Node(value)

            else self.insertNode(currentNode.leftChild, value)

    def deleteNode(self, value):
        if( self.serach(value) == False):
            print("There's no node to delete")
        else:
            tempNode = self.findNode(value)

            childCount = 2

            if tempNode.leftChild is None: childCount -= 1
            if tempNode,rightChild is None: childCount -= 1


            if( childCount == 0 ):   # 자식노드가 없을 때
                tempNode = None

            elif( childCount == 1 ): # 자식 노드가 하나일 떄

                if tempNode.leftChild:

                    tempNode = tempNode.leftChild

                elif tempNode.rightChild:

                    tempNode = tempNode.rightChild

            else:                    #자식 노드가 둘 다 있을 때
                parent = tempNode
                successor = tempNode.right

                while successor.leftChild:
                    parent = successor
                    successor = successor.leftChild

                tempNode.value = sucessor.value

                if parent.leftChild == successor:
                    parrent.leftChild = successor.rightChild

                else:
                    parent.rightChild = successor.rightChild
```


**Balanced vs Unbalanced**

균형(balanced) 트리가 '완전 이진 트리'를 의미 하는 것은 아니다. `insert`와 `find`가 $O(\log N)$시간에 수행되는 정도면 balanced라고 할 수 있다. 대표적인 균형트리는 AVL트리, 레드-블랙 트리가 있다.

**complete binary tree**

complete binary tree, 즉 완전 이진 트리는 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리를 뜻한다. 마지막 단계(level)에서는 모든 노드가 꽉 차 있는 필요는 없지만, 항상 왼쪽에서 오른쪽 순으로 채워져 있어야 한다.

![7](https://i.imgur.com/nyuhEs0.jpg)

**Full binary tree**

Full binary tree, 전 이진 트리는 모든 노드가 자식이 없거나 정확히 2개 있는 경우를 뜻한다. 즉 자식이 하나 있는 노드가 존재해서는 안 된다.

![8](https://i.imgur.com/hglNgm6.jpg)

**Perfect binary tree**

Perfect binary tree, 포화 이진 트리란 전 이진 트리이면서 완전 이진 트리인 경우다. 모든 높이의 노드가 꽉 차 있어야 한다.

포화 이진 트리의 노드 개수는 정확히 $2^{k-1}$개가 된다. ($k$는 트리의 높이)

**기타 트리에 사용되는 용어**
* 차수(degree, 특정 노드의 자식 노드의 수)
* 높이(height, 루트 노드에서 단말 노드까지의 깊이)
* 레벨(level, 각 층의 번호-루트노드:레벨1)

#### 이진트리 순회

전위 중위 후위 순회에 대해서 익숙해지자. 가장 빈번하게 사용되는 방식은 중위 순회이다.

**중위 순회**
왼쪽 자식, 현재 노드, 오른쪽 자식 순이다.

```python
def inOrderTraversal(node):
  if node is not Null:
    inOrderTraversal(node.leftChild)
    visit(node)
    inOrderTraversal(node.rightChild)
```

**전위 순회**
현재 노드, 왼쪽 자식, 오른쪽 자식 순이다.

```python
def preOrderTraversal(node):
  if node is not Null:
    visit(node)
    preOrderTraversal(node.leftChild)
    preOrderTraversal(node.rightChild)
```

**후위 순회**
왼쪽 자식, 오른쪽 자식, 현재 노드 순이다.

```python
def postOrderTraversal(node):
  if node is not Null:
    postOrderTraversal(node.leftChild)
    postOrderTraversal(node.rightChild)
    visit(node)
```

#### 이진 힙

이진 힙(heap)이란 완전 이진 트리(complete binary tree)를 기본으로한 자료구조이다. 힙을 사용하면 최소값, 최대값을 구하기 쉽다. 뿐만 아니라 힙을 이용해 우선순위 큐(priority queue)를 구현했을 때 다른 data structure(e.g. array, linked list, sorted array, sorted linked list)로 구현했을 때보다 시간 복잡도 측면에서 효율적이다.

힙은 다음과 같은 힙 속성(heap property)를 만족한다.
* A가 B의 부모노드(parent node)이면 A의 key값이 B의 key값보다 크다(혹은 작다).

Heap은 대소관계에 따른 두가지 종류가 있다.

* 최대 힙: 부모노드의 키가 자식노드의 키보다 항상 크다.
* 최소 힙: 부모노드의 키가 자식노드의 키보다 항상 작다.
* 형제간에는 대소관계가 성립하지 않는다.

**insert**

최소힙의 경우로 생각한다. 최소힙에서 삽입을 할 때는 항상 트리의 밑바닥에서부터 삽입을 시작한다. 힙 속성에 맞게 계속해서 삽입한 노드를 위로 올린다.

![9](https://i.imgur.com/FOJ47jq.jpg)

위 연산은 노드의 개수를 n이라 할 때 연산은 $O(\log N)$이 된다.

**최소 원소 뽑아내기**

최소 힙에서 최소 값 찾기는 매우 쉽다. 루트 노드가 최소 값을 가진다. 하지만 중요한 것은 뽑아낸 후에 다시 트리를 구성하는 것이 까다롭다는 것이다.

루트 값을 뽑아낸 후에는 가장 마지막 원소(밑바닥 가장 왼쪽 원소)를 루트값으로 만든다. 그 다음에는 이제 루트 아래와 비교해서 작은것과 교체한다.(좌우 모두비교 필요)

![10](https://i.imgur.com/m2hYAdC.jpg)

#### Trie(트라이)

접두사 트리(prefix tree)라고도 불리는 trie는 특이한 data structure이다. trie는 면접과정에서 자주 출제된다.

trie는 n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다. 따라서 트리를 아래쪽으로 순회하면 단어하나가 나온다.

Null node라고도 불리는 '* 노드'는 종종 단어의 끝을 나타낸다. 예를 들어 MANY 이후에 ' * '가 나오면 MANY 라는 단어가 완성되었음을 알린다. ' * '의 경우 구현은 TerminatingTrieNode로 구현될 수도 있고, 아니면 부모 노드 안에 boolean flag를 정의해서 구현할 수도 있다.

trie에서 각 노드는 1개에서  ALPHABET_SIZE + 1 개 까지 자식을 가질 수 있다.   

![11](https://i.imgur.com/NWB8FLP.jpg)

접두사를 빠르게 찾기 위한 흔한 방식으로 특정 문자열이 어떤 유효한 단어의 접두사인지 빠르게 확인할 수 있다.

#### Graph(그래프)

사실 트리는 그래프의 한 종류이다. 사이클이 없는 하나의 연결 그래프가 트리가 된다.

그래프는 단순히 노드와 그 노드를 연결하는 간선(edge)를 모아둔 것이다.

* 그래프는 방향성이 있을 수 있고 없을 수 있다.
* 그래픈느 여러개의 고립된 부분 그래프(isolated subggraphs)로 구성될 수 있다. 모든 정점 쌍(pair of vertices) 간에 경로가 존재하는 그래픈ㄴ느 '연결 그래프'라 부른다.
* 그래프에는 사이클이 존재할 수도 없을 수도 있다. 사이클이 없는 그래프는 비순환 그래프(acyclic graph)라 부른다.

프로그래밍 관점에서 그래프를 표현할 떄는 일반적으로 두 가지 방법을 사용한다. 하나는 인접리스트이고 하나는 인접 행렬이다. 각각 알아보자.

**Adjacency list(인접 리스트)**

인접 리스트는 그래프 표현할 떄 사용되는 일반적인 방법이다. 모든 정점을 인접 리스트에 저장한다. 무방향 그래프에서는 (a,b)간선은 두 번 저장된다. 보통 그래프를 표현하기 위해 배열(or 해시 테이블), 동적 가변 크기 배열, 연결리스트 등을 이용해서 표현할 수 있다.

0: 1
1: 2
2: 0, 3
3: 2
4: 6
5: 4
6: 5

**인접 행렬**

인접행렬은 N X N boolean matrix이다. 간선 (i, j)가 있으면 matrix[i][j] = True(or 1)이 된다. 만약 무방향 그래프라면 대칭 행렬이 된다.

**그래프 탐색**

그래프를 탐색하는 방법은 DFS(깊이 우선 탐색)과 BFS(너비 우선 탐색)이 있다.
