---
layout: post
title:  "임시포스팅2"
date:   2018-08-16 13:47:35 +0900
categories: TensorFlow
tag: tensorflow
---
## Data Structure in Python

Python으로 구현한 Data Structure

**List**  
* Stack / Queue
* Linked List
* Tree
    * Binary Search Tree
* Heaps
* Trie
* Vector / ArrayList
---

#### 1. Stack & Queue

파이썬에서 Stack과 Queue는 리스트로 간단하게 구현할 수 있다.

**Stack**
```python
stack = []
stack.append(1)
stack.append(2)
stack.append(3)
stack.pop() # 3
stack.pop() # 2
stack.pop() # 1
```

**Queue**
```python
queue = []
queue.append(1)
queue.append(2)
queue.append(3)
queue.pop(0) # 1
queue.pop(0) # 2
queue.pop(0) # 3
```

하지만 위와 같은 구현 방식에는 문제가 있다. 기존의 Data Structure로써 Stack 과 Queue는 원소를 넣거나 뺄 때 시간이 $O(1)$ 되는 것이 매우 중요하다. 하지만 리스트로 구현할 때 Stack의 경우 큰 문제는 없지만 Queue의 경우 문제가 발생한다. 리스트로 구현한 Queue에서 원소를 pop하는 과정은 다음과 같다.

0x01    0x02     0x03

[ 1 ] - [ 2 ] - [ 3 ]


 0x01    0x02    0x03

[Null] - [ 2 ] - [ 3 ]



 0x01    0x02    0x03

[ 2 ] - [ 3 ] - [ ? ]


위와 같은 과정으로 pop이 이루어지는데 시간 복잡도가 $O(N)$이 된다. 이는 Data Structure로써 큰 문제점이다. 따라서 파이썬에서 Queue를 사용하기 위해서 Collections의 모듈을 주로 이용한다.

```python
from collections import deque # (*deque는 double ended queue의 약자입니다)
queue = deque()
queue.append(1)
queue.append(2)
queue.popleft() # 1
queue.popleft() # 2
```

위와 같이 Queue를 구현하면 pop과정 시 시간 복잡도가 $O(1)$이 될 뿐만 아니라 collections의 모듈의 경우 C++로 짜여져 있기 떄문에 속도 측면에서 훨씬 빠르다.

**[Bonus] Stack 으로 Queue 구현하기**

stack 2개로 queue를 구현할 수 있다. push된 원소가 제일 위에 있는 기본 stack과 push된 원소가 가장 아래 위치하는 새로운 stack을 구현하면 된다.

```python
class myQueue:
    def __init__(self):
        self.stackNewest = []
        self.stackOldest = []

    def push(self, data):
        self.stackNewest.append(data)
        self.stackOldest = [data] + self.stackOldest

    def pop(self):
        self.stackNewest = self.stackNewest[1:]
        return self.stackOldest.pop()
```

#### 2. Linked List

파이썬에서 Linked List 구현은 다음과 같다.

```python
class Node:

  def __init__(self, data, next = None):
  self.data = data

class LinkedList:

  def __init__(self, data):
    self.head = Node(data)


  def insert(self, data): # 노드 삽입
    current = self.head
    while current.next is not None:
      current = current.next
    current.next = Node(data)    

  def delete(self, data):  # 노드 삭제
    current = self.head

    if current.data == data:
      self.head = self.head.next

    while current.next is not None:

      if current.next.data == data:
        current.next = current.next.next
        break

      current = current.next   
```


#### 4. Tree

파이썬에서의 Tree를 구현하는 방법에 대해서 알아보자. 우선 기본적인 트리의 구현은 다음과 같다.

```python
class Node:
  def __init__(self, value):
    self.value = value
    self.childNode = []

class Tree:
  def __init__(self, value):
    self.root = Node(value)
```

트리는 종류가 많고 복잡하므로 몇 가지 쟁점에 대해서 알아보자.

**Tree vs Binary Tree**

Binary tree는 각 노드가 최대 두 개의 자식을 갖는 트리를 말한다. 모든 트리는 binary tree 가 아니다. 일반적으로는 자식을 2개 이상 가질 수 있다.

**Binary Tree vs Binary Search Tree**

Binary Tree(이진 트리)와 Binary Search Tree(이진 탐색 트리)를 구분해야 한다. 구조는 갖지만 binary search tree의 경우 모든 노드들에 대해 left child 노드는 해당 노드보다 크기가 작아야 하고 right child 노드는 해당 노드보다 크기가 커야 한다.

![3](https://i.imgur.com/uHyuFDV.jpg)

이진 트리와 이진 탐색 트리를 각각 python으로 구현해 보자.

**Binary Tree**
이진 트리의 경우 기존의 트리와 구현이 크게 다른점이 없으므로 간단하게만 구현한다.

```python
class Node:
  def __init__(self, value):
    self.value = value
    self.leftChild = None
    self.rightChild = None

class Tree:
  def __init__(self, value):
    self.root = Node(value)

  def setRoot(..):
    ...

  def insert(..):
    ...

  def delete(..):
    ...

  ...
```

**Binary Search Tree**
이진 탐색 트리의 경우 구현이 쉽지는 않다. 특히 노드 삭제가 매우 어렵다. 삭제의 경우 삭제할 노드를 아래와 같이 구분해줘야 한다.

* 삭제할 노드의 자식 노드가 없는 경우

가장 간단한 구조이다. 그냥 삭제만 하면 끝난다.

![4](https://i.imgur.com/NigLpS6.jpg)

* 삭제할 노드의 자식 노드가 하나인 경우

이 경우도 그렇게 어렵지는 않다. 삭제한뒤 해당 노드의 부모에 해당 노드의 자식노드를 이어주면 끝난다.

![5](https://i.imgur.com/UqLOVak.jpg)

* 자식 노드가 2개인 경우

가장 문제가 되는 case다. 삭제후 바로 연결해 버리면 Binary Search Tree의 가정이 어긋나게 된다. 삭제하는 방법은 삭제한 노드의 우측 서브 트리에서 successor(최소값)을 찾는다. successor값을 삭제하는 노드의 값으로 지정해준다. 그리고 successor 노드를 지우면 된다. successor 노드의 경우 항상 자식노드가 하나 혹은 없을 수 밖에 없으므로 이 노드의 삭제는 간단하다.

![6](https://i.imgur.com/4xq6kFo.jpg)

Python으로 Binary Search Tree 구현한 것은 다음과 같다.

```python
class Node:
    def __init__(self, val):
        self.value = None
        self.leftChild = None
        self.rightChild = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def setRoot(self, value):
        self.root = Node(value)

    def search(self, value):

        if self.binarySearch(root, value): return self.binarySearch(root, value)

        else: return False

    def binarySearch(self, node, value):

        if node is None: return False

        else:
            if node.value > value:
                binarySearch(node.leftChild.value, value)

            elif node.value < value:
                binarySearch(no.rightChild.value, value)

            else return node

    def insert(self, value):
        if self.root is None:
            self.setRoot(value)
        else:
            self.insertNode(self.root, value)

    def insertNode(self, currentNode, value):

        if value >= currentNode:

            if currentNode.rightChild is None: currentNode.rightChild = Node(value)

            else self.insertNode(currentNode.rightChild, value)

        else:

            if currentNode.leftChild is None: currentNode.leftChild = Node(value)

            else self.insertNode(currentNode.leftChild, value)

    def deleteNode(self, value):
        if( self.serach(value) == False):
            print("There's no node to delete")
        else:
            tempNode = self.findNode(value)

            childCount = 2

            if tempNode.leftChild is None: childCount -= 1
            if tempNode,rightChild is None: childCount -= 1


            if( childCount == 0 ):   # 자식노드가 없을 때
                tempNode = None

            elif( childCount == 1 ): # 자식 노드가 하나일 떄

                if tempNode.leftChild:

                    tempNode = tempNode.leftChild

                elif tempNode.rightChild:

                    tempNode = tempNode.rightChild

            else:                    #자식 노드가 둘 다 있을 때
                parent = tempNode
                successor = tempNode.right

                while successor.leftChild:
                    parent = successor
                    successor = successor.leftChild

                tempNode.value = sucessor.value

                if parent.leftChild == successor:
                    parrent.leftChild = successor.rightChild

                else:
                    parent.rightChild = successor.rightChild
```


**Balanced vs Unbalanced**

균형(balanced) 트리가 '완전 이진 트리'를 의미 하는 것은 아니다. `insert`와 `find`가 $O(\log N)$시간에 수행되는 정도면 balanced라고 할 수 있다. 대표적인 균형트리는 AVL트리, 레드-블랙 트리가 있다.

**complete binary tree**

complete binary tree, 즉 완전 이진 트리는 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리를 뜻한다. 마지막 단계(level)에서는 모든 노드가 꽉 차 있는 필요는 없지만, 항상 왼쪽에서 오른쪽 순으로 채워져 있어야 한다.

![7](https://i.imgur.com/nyuhEs0.jpg)

**Full binary tree**

Full binary tree, 전 이진 트리는 모든 노드가 자식이 없거나 정확히 2개 있는 경우를 뜻한다. 즉 자식이 하나 있는 노드가 존재해서는 안 된다.

![8](https://i.imgur.com/hglNgm6.jpg)

**Perfect binary tree**

Perfect binary tree, 포화 이진 트리란 전 이진 트리이면서 완전 이진 트리인 경우다. 모든 높이의 노드가 꽉 차 있어야 한다.

포화 이진 트리의 노드 개수는 정확히 $2^{k-1}$개가 된다. ($k$는 트리의 높이)

**기타 트리에 사용되는 용어**
* 차수(degree, 특정 노드의 자식 노드의 수)
* 높이(height, 루트 노드에서 단말 노드까지의 깊이)
* 레벨(level, 각 층의 번호-루트노드:레벨1)


#### 5. Heap

이진 힙(heap)이란 완전 이진 트리(complete binary tree)를 기본으로한 자료구조이다. 힙을 사용하면 최소값, 최대값을 구하기 쉽다. 뿐만 아니라 힙을 이용해 우선순위 큐(priority queue)를 구현했을 때 다른 data structure(e.g. array, linked list, sorted array, sorted linked list)로 구현했을 때보다 시간 복잡도 측면에서 효율적이다.

힙은 다음과 같은 힙 속성(heap property)를 만족한다.
* A가 B의 부모노드(parent node)이면 A의 key값이 B의 key값보다 크다(혹은 작다).

Heap은 대소관계에 따른 두가지 종류가 있다.

* 최대 힙: 부모노드의 키가 자식노드의 키보다 항상 크다.
* 최소 힙: 부모노드의 키가 자식노드의 키보다 항상 작다.
* 형제간에는 대소관계가 성립하지 않는다.

**insert**

최소힙의 경우로 생각한다. 최소힙에서 삽입을 할 때는 항상 트리의 밑바닥에서부터 삽입을 시작한다. 힙 속성에 맞게 계속해서 삽입한 노드를 위로 올린다.

![9](https://i.imgur.com/FOJ47jq.jpg)

위 연산은 노드의 개수를 n이라 할 때 연산은 $O(\log N)$이 된다.

**최소 원소 뽑아내기**

최소 힙에서 최소 값 찾기는 매우 쉽다. 루트 노드가 최소 값을 가진다. 하지만 중요한 것은 뽑아낸 후에 다시 트리를 구성하는 것이 까다롭다는 것이다.

루트 값을 뽑아낸 후에는 가장 마지막 원소(밑바닥 가장 왼쪽 원소)를 루트값으로 만든다. 그 다음에는 이제 루트 아래와 비교해서 작은것과 교체한다.(좌우 모두비교 필요)

![10](https://i.imgur.com/m2hYAdC.jpg)

#6. Trie

접두사 트리(prefix tree)라고도 불리는 trie는 특이한 data structure이다. trie는 면접과정에서 자주 출제된다.

trie는 n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다. 따라서 트리를 아래쪽으로 순회하면 단어하나가 나온다.

Null node라고도 불리는 '* 노드'는 종종 단어의 끝을 나타낸다. 예를 들어 MANY 이후에 ' * '가 나오면 MANY 라는 단어가 완성되었음을 알린다. ' * '의 경우 구현은 TerminatingTrieNode로 구현될 수도 있고, 아니면 부모 노드 안에 boolean flag를 정의해서 구현할 수도 있다.

trie에서 각 노드는 1개에서  ALPHABET_SIZE + 1 개 까지 자식을 가질 수 있다.   

![11](https://i.imgur.com/NWB8FLP.jpg)

접두사를 빠르게 찾기 위한 흔한 방식으로 특정 문자열이 어떤 유효한 단어의 접두사인지 빠르게 확인할 수 있다.
